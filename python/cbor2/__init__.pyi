import sys
from collections.abc import Callable, Iterator, Mapping, Sequence
from datetime import date, datetime, tzinfo
from decimal import Decimal
from email.message import Message
from email.mime.text import MIMEText
from fractions import Fraction
from ipaddress import (
    IPv4Address,
    IPv4Interface,
    IPv4Network,
    IPv6Address,
    IPv6Interface,
    IPv6Network,
)
from re import Pattern
from typing import IO, Any, Generic, TypeAlias, TypeVar, final
from uuid import UUID

if sys.version_info >= (3, 11):
    from typing import Self
else:
    from typing_extensions import Self

_T = TypeVar("_T")
_T_co = TypeVar("_T_co", covariant=True)
_KT = TypeVar("_KT")
_VT_co = TypeVar("_VT_co", covariant=True)

TagHook: TypeAlias = Callable[[CBORDecoder, CBORTag], Any]
MajorDecoderCallback: TypeAlias = Callable[[CBORDecoder, int], Any]
SemanticDecoderCallback: TypeAlias = Callable[[CBORDecoder], Any]
ObjectHook: TypeAlias = Callable[[CBORDecoder, dict[Any, Any]], Any]
EncoderHook: TypeAlias = Callable[[CBOREncoder, Any], Any]

@final
class CBOREncoder:
    datetime_as_timestamp: bool
    timezone: tzinfo | None
    value_sharing: bool
    default: EncoderHook | None
    canonical: bool
    date_as_datetime: bool
    string_referencing: bool
    indefinite_containers: bool
    def __new__(
        cls,
        fp: IO[bytes],
        *,
        datetime_as_timestamp: bool = ...,
        timezone: tzinfo | None = ...,
        value_sharing: bool = ...,
        encoders: Mapping[type, EncoderHook] | None = ...,
        default: EncoderHook | None = ...,
        canonical: bool = ...,
        date_as_datetime: bool = ...,
        string_referencing: bool = ...,
        indefinite_containers: bool = ...,
    ) -> Self: ...
    fp: IO[bytes]
    def flush(self) -> None: ...
    def write(self, buf: bytes, /) -> int: ...
    def encode(self, obj: object, /) -> None: ...
    def encode_to_bytes(self, obj: object, /) -> bytes: ...
    def encode_length(self, major_tag: int, length: int | None) -> None: ...
    def encode_string(self, obj: str) -> None: ...
    def encode_bytes(self, obj: bytes) -> None: ...
    def encode_bytearray(self, obj: bytearray) -> None: ...
    def encode_array(self, obj: Sequence[Any]) -> None: ...
    def encode_map(self, obj: Mapping[Any, Any]) -> None: ...
    def encode_break(self) -> None: ...
    def encode_int(self, obj: int) -> None: ...
    def encode_bool(self, obj: bool) -> None: ...
    def encode_none(self) -> None: ...
    def encode_undefined(self) -> None: ...
    def encode_semantic(self, tag: int, value: Any) -> None: ...
    def encode_set(self, obj: set[Any]) -> None: ...
    def encode_frozenset(self, obj: frozenset[Any]) -> None: ...
    def encode_datetime(self, obj: datetime) -> None: ...
    def encode_date(self, obj: date) -> None: ...
    def encode_rational(self, obj: Fraction) -> None: ...
    def encode_regexp(self, obj: Pattern[str]) -> None: ...
    def encode_mime(self, obj: MIMEText) -> None: ...
    def encode_uuid(self, obj: UUID) -> None: ...
    def encode_decimal(self, obj: Decimal) -> None: ...
    def encode_ipv4_address(self, obj: IPv4Address) -> None: ...
    def encode_ipv4_network(self, obj: IPv4Network) -> None: ...
    def encode_ipv4_interface(self, obj: IPv4Interface) -> None: ...
    def encode_ipv6_address(self, obj: IPv6Address) -> None: ...
    def encode_ipv6_network(self, obj: IPv6Network) -> None: ...
    def encode_ipv6_interface(self, obj: IPv6Interface) -> None: ...
    def encode_simple_value(self, obj: CBORSimpleValue) -> None: ...
    def encode_float(self, obj: float) -> None: ...
    def encode_complex(self, obj: complex) -> None: ...

@final
class CBORDecoder:
    fp: IO[bytes]
    tag_hook: TagHook | None
    object_hook: ObjectHook | None
    str_errors: str
    read_size: int
    max_depth: int
    immutable: bool
    def __new__(
        cls,
        fp: IO[bytes],
        *,
        tag_hook: TagHook | None = ...,
        object_hook: ObjectHook | None = ...,
        major_decoders: Mapping[int, MajorDecoderCallback] | None = ...,
        semantic_decoders: Mapping[int, SemanticDecoderCallback] | None = ...,
        str_errors: str = ...,
        read_size: int = ...,
        max_depth: int = ...,
    ) -> Self: ...
    def decode(self) -> Any: ...
    def decode_from_bytes(self, buf: bytes, /) -> Any: ...
    def read(self, amount: int, /) -> bytes: ...

    # Low-level decoder helpers
    def decode_length(self, subtype: int) -> int | None: ...
    def set_shareable(self, obj: object, /) -> None: ...

    # Major decoders
    def decode_uint(self, subtype: int) -> int: ...
    def decode_negint(self, subtype: int) -> int: ...
    def decode_bytestring(self, subtype: int) -> bytes: ...
    def decode_string(self, subtype: int) -> str: ...
    def decode_array(self, subtype: int) -> list[Any] | tuple[Any, ...]: ...
    def decode_map(self, subtype: int) -> dict[Any, Any] | FrozenDict[Any, Any]: ...
    def decode_semantic(self, subtype: int) -> Any: ...
    def decode_special(self, subtype: int) -> Any: ...

    # Semantic decoders
    def decode_datetime_string(self) -> datetime: ...
    def decode_epoch_datetime(self) -> datetime: ...
    def decode_positive_bignum(self) -> int: ...
    def decode_negative_bignum(self) -> int: ...
    def decode_fraction(self) -> Decimal: ...
    def decode_bigfloat(self) -> Decimal: ...
    def decode_stringref(self) -> str: ...
    def decode_shareable(self) -> Any: ...
    def decode_sharedref(self) -> Any: ...
    def decode_rational(self) -> Fraction: ...
    def decode_regexp(self) -> Pattern[str]: ...
    def decode_mime(self) -> Message: ...
    def decode_uuid(self) -> UUID: ...
    def decode_ipv4(self) -> IPv4Address | IPv4Network | IPv4Interface: ...
    def decode_ipv6(self) -> IPv6Address | IPv6Network | IPv6Interface: ...
    def decode_epoch_date(self) -> date: ...
    def decode_stringref_namespace(self) -> Any: ...
    def decode_set(self) -> set[Any] | frozenset[Any]: ...
    def decode_ipaddress(self) -> IPv4Address | IPv6Address: ...
    def decode_ipnetwork(self) -> IPv4Network | IPv4Interface | IPv6Network | IPv6Interface: ...
    def decode_date_string(self) -> date: ...
    def decode_complex(self) -> complex: ...
    def decode_self_describe_cbor(self) -> Any: ...

class CBORError(Exception): ...
class CBOREncodeError(CBORError): ...
class CBOREncodeTypeError(CBOREncodeError, TypeError): ...
class CBOREncodeValueError(CBOREncodeError, ValueError): ...
class CBORDecodeError(CBORError): ...
class CBORDecodeValueError(CBORDecodeError, ValueError): ...
class CBORDecodeEOF(CBORDecodeError, EOFError): ...

@final
class FrozenDict(Generic[_KT, _VT_co], Mapping[_KT, _VT_co]):
    def __new__(cls, *args: Any, **kwargs: Any) -> Self: ...
    def __getitem__(self, key: _KT, /) -> _VT_co: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[_T_co]: ...

@final
class CBORTag:
    tag: int
    value: Any

    def __new__(cls, tag: int, value: Any) -> Self: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object, /) -> bool: ...
    def __gt__(self, other: object, /) -> bool: ...
    def __ge__(self, other: object, /) -> bool: ...

@final
class CBORSimpleValue:
    value: int

    def __new__(cls, value: int) -> Self: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object, /) -> bool: ...
    def __gt__(self, other: object, /) -> bool: ...
    def __ge__(self, other: object, /) -> bool: ...

@final
class BreakMarkerType: ...

@final
class UndefinedType: ...

undefined: UndefinedType
break_marker: BreakMarkerType

def dump(
    obj: object,
    fp: IO[bytes],
    *,
    datetime_as_timestamp: bool = ...,
    timezone: tzinfo | None = ...,
    value_sharing: bool = ...,
    encoders: Mapping[type, EncoderHook] | None = ...,
    default: EncoderHook | None = ...,
    canonical: bool = ...,
    date_as_datetime: bool = ...,
    string_referencing: bool = ...,
    indefinite_containers: bool = ...,
) -> None: ...
def dumps(
    obj: object,
    *,
    datetime_as_timestamp: bool = ...,
    timezone: tzinfo | None = ...,
    value_sharing: bool = ...,
    encoders: Mapping[type, EncoderHook] | None = ...,
    default: EncoderHook | None = ...,
    canonical: bool = ...,
    date_as_datetime: bool = ...,
    string_referencing: bool = ...,
    indefinite_containers: bool = ...,
) -> bytes: ...
def load(
    fp: IO[bytes],
    *,
    tag_hook: TagHook | None = ...,
    object_hook: ObjectHook | None = ...,
    major_decoders: Mapping[int, MajorDecoderCallback] | None = ...,
    semantic_decoders: Mapping[int, SemanticDecoderCallback] | None = ...,
    str_errors: str = ...,
    max_depth: int = ...,
) -> Any: ...
def loads(
    data: bytes,
    *,
    tag_hook: TagHook | None = ...,
    object_hook: ObjectHook | None = ...,
    major_decoders: Mapping[int, MajorDecoderCallback] | None = ...,
    semantic_decoders: Mapping[int, SemanticDecoderCallback] | None = ...,
    str_errors: str = ...,
    max_depth: int = ...,
) -> Any: ...
def shareable_encoder(
    wraps: Callable[[CBOREncoder, _T], None], /
) -> Callable[[CBOREncoder, _T], None]: ...

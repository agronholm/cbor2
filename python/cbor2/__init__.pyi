import sys
from collections.abc import Callable, Iterator, Mapping
from datetime import date, datetime, tzinfo
from decimal import Decimal
from email.message import Message
from fractions import Fraction
from ipaddress import (
    IPv4Address,
    IPv4Interface,
    IPv4Network,
    IPv6Address,
    IPv6Interface,
    IPv6Network,
)
from re import Pattern
from typing import _KT, IO, Any, Generic, TypeAlias, TypeVar, _T_co, _VT_co
from uuid import UUID

if sys.version_info >= (3, 11):
    from typing import Self
else:
    from typing_extensions import Self

_T = TypeVar("_T")

TagHook: TypeAlias = Callable[[CBORDecoder, CBORTag], Any]
MajorDecoderCallback: TypeAlias = Callable[[CBORDecoder, int], Any]
SemanticDecoderCallback: TypeAlias = Callable[[CBORDecoder], Any]
ObjectHook: TypeAlias = Callable[[CBORDecoder, dict[Any, Any]], Any]
EncoderHook: TypeAlias = Callable[[CBOREncoder, Any], Any]

class CBOREncoder:
    datetime_as_timestamp: bool
    timezone: tzinfo | None
    value_sharing: bool
    default: EncoderHook | None
    canonical: bool
    date_as_datetime: bool
    string_referencing: bool
    indefinite_containers: bool
    def __new__(
        cls,
        fp: IO[bytes],
        *,
        datetime_as_timestamp: bool = ...,
        timezone: tzinfo | None = ...,
        value_sharing: bool = ...,
        default: EncoderHook | None = ...,
        canonical: bool = ...,
        date_as_datetime: bool = ...,
        string_referencing: bool = ...,
        indefinite_containers: bool = ...,
    ) -> Self: ...
    fp: IO[bytes]
    def flush(self) -> None: ...
    def write(self, buf: bytes, /) -> None: ...
    def encode(self, obj: object, /) -> None: ...
    def encode_to_bytes(self, obj: object, /) -> bytes: ...
    def encode_length(self, major_tag: int, length: int | None) -> None: ...
    def encode_break(self) -> None: ...

class CBORDecoder:
    fp: IO[bytes]
    tag_hook: TagHook | None
    object_hook: ObjectHook | None
    str_errors: str
    read_size: int
    max_depth: int
    immutable: bool
    def __new__(
        cls,
        fp: IO[bytes],
        *,
        tag_hook: TagHook | None = ...,
        object_hook: ObjectHook | None = ...,
        major_decoders: Mapping[int, MajorDecoderCallback] | None = ...,
        semantic_decoders: Mapping[int, SemanticDecoderCallback] | None = ...,
        str_errors: str = ...,
        read_size: int = ...,
        max_depth: int = ...,
    ) -> Self: ...
    def decode(self) -> Any: ...
    def decode_from_bytes(self, buf: bytes, /) -> Any: ...
    def read(self, amount: int) -> bytes: ...

    # Low-level decoder helpers
    def decode_length(self, subtype: int) -> int | None: ...
    def set_shareable(self, value: object, /) -> None: ...

    # Major decoders
    def decode_uint(self, subtype: int) -> int: ...
    def decode_negint(self, subtype: int) -> int: ...
    def decode_bytestring(self, subtype: int) -> bytes: ...
    def decode_string(self, subtype: int) -> str: ...
    def decode_array(self, subtype: int) -> list[Any] | tuple[Any, ...]: ...
    def decode_map(self, subtype: int) -> dict[Any, Any] | FrozenDict[Any, Any]: ...
    def decode_semantic(self, subtype: int) -> Any: ...
    def decode_special(self, subtype: int) -> Any: ...

    # Semantic decoders
    def decode_datetime_string(self) -> datetime: ...
    def decode_epoch_datetime(self) -> datetime: ...
    def decode_positive_bignum(self) -> int: ...
    def decode_negative_bignum(self) -> int: ...
    def decode_fraction(self) -> Decimal: ...
    def decode_stringref(self) -> str: ...
    def decode_shareable(self) -> Any: ...
    def decode_sharedref(self) -> Any: ...
    def decode_rational(self) -> Fraction: ...
    def decode_regexp(self) -> Pattern[str]: ...
    def decode_mime(self) -> Message: ...
    def decode_uuid(self) -> UUID: ...
    def decode_ipv4(self) -> IPv4Address | IPv4Network | IPv4Interface: ...
    def decode_ipv6(self) -> IPv6Address | IPv6Network | IPv6Interface: ...
    def decode_epoch_date(self) -> date: ...
    def decode_stringref_namespace(self) -> Any: ...
    def decode_set(self) -> set[Any] | frozenset[Any]: ...
    def decode_ipaddress(self) -> IPv4Address | IPv6Address: ...
    def decode_ipnetwork(self) -> IPv4Network | IPv4Interface | IPv6Network | IPv6Interface: ...
    def decode_date_string(self) -> date: ...
    def decode_complex(self) -> complex: ...
    def decode_self_describe_cbor(self) -> Any: ...

class CBORError(Exception): ...
class CBOREncodeError(CBORError): ...
class CBOREncodeTypeError(CBOREncodeError, TypeError): ...
class CBOREncodeValueError(CBOREncodeError, ValueError): ...
class CBORDecodeError(CBORError): ...
class CBORDecodeValueError(CBORDecodeError, ValueError): ...
class CBORDecodeEOF(CBORDecodeError, EOFError): ...

class FrozenDict(Generic[_KT, _VT_co], Mapping[_KT, _VT_co]):
    def __new__(cls, *args: Any) -> Self: ...
    def __getitem__(self, key: _KT, /) -> _VT_co:
        pass

    def __len__(self) -> int:
        pass

    def __iter__(self) -> Iterator[_T_co]:
        pass

class CBORTag:
    tag: int
    value: Any

    def __new__(cls, tag: int, value: Any) -> Self: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object, /) -> bool: ...
    def __gt__(self, other: object, /) -> bool: ...
    def __ge__(self, other: object, /) -> bool: ...

class CBORSimpleValue:
    value: int

    def __new__(cls, value: int) -> Self: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __lt__(self, other: object) -> bool: ...
    def __le__(self, other: object, /) -> bool: ...
    def __gt__(self, other: object, /) -> bool: ...
    def __ge__(self, other: object, /) -> bool: ...

class BreakMarkerType: ...
class UndefinedType: ...

undefined: UndefinedType
break_marker: BreakMarkerType

encoders: dict[type, Callable[[CBOREncoder, Any], None]]

def dump(
    obj: object,
    fp: IO[bytes],
    *,
    datetime_as_timestamp: bool = ...,
    timezone: tzinfo | None = ...,
    value_sharing: bool = ...,
    default: EncoderHook | None = ...,
    canonical: bool = ...,
    date_as_datetime: bool = ...,
    string_referencing: bool = ...,
    indefinite_containers: bool = ...,
) -> None: ...
def dumps(
    obj: object,
    *,
    datetime_as_timestamp: bool = ...,
    timezone: tzinfo | None = ...,
    value_sharing: bool = ...,
    default: EncoderHook | None = ...,
    canonical: bool = ...,
    date_as_datetime: bool = ...,
    string_referencing: bool = ...,
    indefinite_containers: bool = ...,
) -> bytes: ...
def load(
    fp: IO[bytes],
    *,
    tag_hook: TagHook | None = ...,
    object_hook: ObjectHook | None = ...,
    major_decoders: Mapping[int, MajorDecoderCallback] | None = ...,
    semantic_decoders: Mapping[int, SemanticDecoderCallback] | None = ...,
    str_errors: str = ...,
    max_depth: int = ...,
) -> Any: ...
def loads(
    data: bytes,
    *,
    tag_hook: TagHook | None = ...,
    object_hook: ObjectHook | None = ...,
    major_decoders: Mapping[int, MajorDecoderCallback] | None = ...,
    semantic_decoders: Mapping[int, SemanticDecoderCallback] | None = ...,
    str_errors: str = ...,
    max_depth: int = ...,
) -> Any: ...
def shareable_encoder(
    wraps: Callable[[CBOREncoder, _T], None], /
) -> Callable[[CBOREncoder, _T], None]: ...
